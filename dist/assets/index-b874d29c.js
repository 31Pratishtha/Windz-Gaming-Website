import{t as V,v as C,x,y as M,r as v}from"./index-15ab2af5.js";function O(e){e.values.forEach(t=>t.stop())}function T(){const e=new Set,t={subscribe(r){return e.add(r),()=>void e.delete(r)},start(r,s){const u=[];return e.forEach(o=>{u.push(V(o,r,{transitionOverride:s}))}),Promise.all(u)},set(r){return e.forEach(s=>{C(s,r)})},stop(){e.forEach(r=>{O(r)})},mount(){return()=>{t.stop()}}};return t}function _(){const e=x(T);return M(e.mount,[]),e}const W=_;var R=new Map,b=new WeakMap,I=0,B=void 0;function $(e){return e?(b.has(e)||(I+=1,b.set(e,I.toString())),b.get(e)):"0"}function j(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?$(e.root):e[t]}`).toString()}function z(e){let t=j(e),r=R.get(t);if(!r){const s=new Map;let u;const o=new IntersectionObserver(i=>{i.forEach(n=>{var a;const l=n.isIntersecting&&u.some(f=>n.intersectionRatio>=f);e.trackVisibility&&typeof n.isVisible>"u"&&(n.isVisible=l),(a=s.get(n.target))==null||a.forEach(f=>{f(l,n)})})},e);u=o.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),r={id:t,observer:o,elements:s},R.set(t,r)}return r}function L(e,t,r={},s=B){if(typeof window.IntersectionObserver>"u"&&s!==void 0){const a=e.getBoundingClientRect();return t(s,{isIntersecting:s,target:e,intersectionRatio:typeof r.threshold=="number"?r.threshold:0,time:0,boundingClientRect:a,intersectionRect:a,rootBounds:a}),()=>{}}const{id:u,observer:o,elements:i}=z(r);let n=i.get(e)||[];return i.has(e)||i.set(e,n),n.push(t),o.observe(e),function(){n.splice(n.indexOf(t),1),n.length===0&&(i.delete(e),o.unobserve(e)),i.size===0&&(o.disconnect(),R.delete(u))}}function q({threshold:e,delay:t,trackVisibility:r,rootMargin:s,root:u,triggerOnce:o,skip:i,initialInView:n,fallbackInView:a,onChange:l}={}){var f;const[h,S]=v.useState(null),g=v.useRef(),[m,w]=v.useState({inView:!!n,entry:void 0});g.current=l,v.useEffect(()=>{if(i||!h)return;let d;return d=L(h,(A,E)=>{w({inView:A,entry:E}),g.current&&g.current(A,E),E.isIntersecting&&o&&d&&(d(),d=void 0)},{root:u,rootMargin:s,threshold:e,trackVisibility:r,delay:t},a),()=>{d&&d()}},[Array.isArray(e)?e.toString():e,h,u,s,o,i,r,a,t]);const p=(f=m.entry)==null?void 0:f.target,y=v.useRef();!h&&p&&!o&&!i&&y.current!==p&&(y.current=p,w({inView:!!n,entry:void 0}));const c=[S,m.inView,m.entry];return c.ref=c[0],c.inView=c[1],c.entry=c[2],c}export{W as a,q as u};
